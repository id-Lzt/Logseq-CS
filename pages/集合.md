- ## [[ArrayList]]
	- ### 初始化
		- jdk1.8之前默认长度为10，同时扩容的时候是取余
		- jdk1.8之后先创建的是空数组，然后添加第一个元素后才会将长度变为10，扩容时是位运算
- ## [[LinkedList]]
- ## [[HashSet]]
- ## [[HashMap]]
	- ### 初始化
		- 先创建的是空数组，然后put添加第一个元素后才会将长度变为16
	- ### 添加元素
		- 通过key计算得到hash值查找到对应位置
			- 将key通过哈希函数计算得到的hash值无符号右移16位于原先哈希值求异或得到真正的哈希值（相当于高八位和低八位），然后将hash值与数组的长度length-1进行求与运算，其范围刚好在length之内，这个数作为value的存储位置，
		- 如果对应位置为空则直接加入
		- 如果对应存储位置存在链表再通过key进行查询添加在末尾，之后根据其长度决定是否将链表替换成红黑树
		- 或者对应存储位置存在红黑树就按照红黑树的规则进行添加。
- ## ConcurrentHashMap
- ## LinkedHashMap
- ## [[Queue]]
- ## [[Deque]]
- ## [[Stack]]
- ## [[Math]]
- ## 面试
	- ### ArrayList与LinkedList的区别
		- 底层实现：
			- ArrayList底层是数组，查找某个元素的时间复杂度是O(1)
			- LinkedList以元素列表的形式进行数据存储，每一个节点存储两个引用一个指向上一个元素，一个指向下一个元素，查找某个元素的时间复杂度是O(n)
		- 扩容：
			- arraylist每次当长度不足时，进行长度扩容，将原先长度二进制右移一位的值与原先长度相加，就是原先长度的1.5倍,扩容后会通过Arrays.copyof()进行拷贝
			- linkedlist则由于是链表，不存在扩容
		- 作用：
			- ArrayList搜索快，LinkedList增删快
	- ### HashMap为什么达到大小的0.75倍时进行扩容
		- 根据泊松分布，当取0.75时空间和时间效率最佳
	- ### HashMap为什么使用红黑树？
		- 红黑树需要进行左旋，右旋，变色这些操作来保持平衡
		- 当存储元素较少时，链表的性能更佳
		- 当数量足够多时红黑树查询效率会提高