- ## 垃圾选择机制
	- ### 引用计数法
		- 给对象添加引用计数器，每当有一个地方引用了，计数就加1，每当引用失效了，计数就减一，任何时候引用计数为0时，对象就是不可再被使用的。
	- ### 可达性分析算法
	- 现代虚拟机基本都是采用可达性分析算法来判断对象是否存活，
		- #### 原理
			- 以一系列叫做[[GC Root]]  的对象为起点出发， 将对象串成的一条引用链，直到所有对象都遍历完毕,如果相关对象不在任意一个以 GC Root 为起点的引用链中，则这些对象会被判断为垃圾对象,会被 GC 回收。
- ## GC垃圾回收清除机制
	- ### 针对区域
		- 垃圾回收主要针对的区域是堆内存、方法区(JDK1.8以前)，JDK1.8方法区取消，改为元数据区。
		- 程序计数器、虚拟机栈、本地方法栈，这几块内存空间，GC是不考虑的，因为它们与线程共生死，线程结束，这里的内存也将自动被释放。
	- ### 标记-清除法
		- 该回收机制即为表面意思，先标记，然后把标记的内存回收，即释放。
		- 该回收算法容易产生很多内存碎片，导致大的对象没有足够的连续内存，会触发GC。举例，该网格图为JVM堆内存，每块网格为一块内存，假设白色的格是通过标记清除法释放的内存
	- ### 标记-整理法
		- 标记整理法，与标记清除法一样，只不过是多了一个整理的步骤，在标记清除完之后，会将内存进行归整，使内存碎片能够连续，避免了标记清除回收算法的弊端
	- ### 复制算法
		- 将内存平均分成A、B两块，算法过程：
		- 新生对象被分配到A块中未使用的内存当中。当A块的内存用完了，清理A块所有对象， 把A块的存活对象对象复制到B块。
		- 新生对象被分配的B块中未使用的内存当中。当B块的内存用完了， 把B块的存活对象对象复制到A块。
		  清理B块所有对象。
- ##### 堆如何进行垃圾回收清理？
- 堆分为新生代，老年代
- 年轻代用来存放新近创建的对象。大小随堆大小的增大和减小而相应的变化，默认值是保持堆大小的1/15
- 新生代又分为eden区，两个幸存区s0,s1,三者区域大小比默认是8:1:1
- Eden+S0可分配新生对象；
- 对Eden+S0进行垃圾收集，存活对象复制到S1。清理Eden+S0。一次新生代GC结束。
- 再对Eden+S1可分配新生对象；
- 对Eden+S1进行垃圾收集，存活对象复制到S0。清理Eden+S1。二次新生代GC结束。
- 老年代垃圾回收和新生代垃圾回收的区别
- Full GC发生的次数不会有Minor GC那么频繁，并且进行一次Full GC要比进行一次Minor GC的时间更长
- ##### 对象如何由新生代进入老年代？
- 对象在s0,s1区每熬过一次Minor GC，就将对象的年龄加1，当对象的年龄到达某个值时(默认是15，可以通过参数-XX:MaxTenuringThreshold来设定),就会进入老年代
- 如果对象创建是本身就需要很大的连续内存也会直接进入老年代
- ## finalize()方法
	- ### 作用
		- 在对象经过垃圾识别算法后，不在意GCroot为起点的引用链上后，会判断对象是否重写了finalize方法，如果重写了就调用，主要用于进行垃圾回收前的工作
	- ### 缺点
		- finalize()只会被调用一次，及时在finalize方法中将对象恢复为存活状态，之后再次被判定为可回收对象后就不会再运行了
		- finalize()的优先级较低，有一个自己的相关线程在处理器任务，不能及时的将其内部任务完成