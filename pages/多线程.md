- ## 线程状态
	- 新建态 ：[[Thread类]]，[[Runnable接口]]，[[Callable接口]]
	- 新建态-->就绪态 ：调用Thread.start()方法
	-
	- [[就绪态]]-->运行态 ：等待到CPU执行权
	-
	- [[运行态]]-->就绪态 ：线程礼让：[[Thread.yield()方法]]
	- 运行态-->阻塞态 ：[[Thread.sleep()方法]]，[[Thread.join()方法]]，[[锁对象.wait()方法]]
	- 运行态-->死亡态 ：Thread.stop()方法，线程自然运行结束
	-
	- [[阻塞态]]—>运行态
- ## 线程同步
	- [[volatile]]
	- 锁
		- [[Synchronized]]
		- [[ReentrantLock]]
	- [[锁对象.wait()方法]]
- ## 守护线程
	- 实现 ：通过Thread.setDemon(false),来将用户线程变成守护线程，
	- 当所有用户线程结束时，守护线程也会自己销毁及时其有任务在运行，除了这一个特点其他和用户线程相同，比如：GC垃圾回收线程
- ## 协程
	- 用户态的轻量级线程
	- 协程切换时，将寄存器上下文和栈保存到其他地方，在切回来后直接恢复，基本没有内核切换的开销，极大提高了线程切换的效率
	- 同一时间只有一个协程拥有使用权，相对于单线程的能力
- ## 面试
	- ### 为什么使用多线程？
		- 因为单线程处理能力低。打个比方，一个人去搬砖与几个人去搬砖，一个人只能同时搬一车，但是几个人可以同时一起搬多个车。
	- ### java为什么需要线程同步？
		- 当多个线程访问同一数据并作出修改时，为保证其逻辑的有序性所以需要实现线程同步，多个线程按照一定次序进行访问。
	- ### sleep和wait的区别：
	  使用位置：
		- wait()只能用于同步必须包裹在synchronized下面，sleep()什么情况下的线程中都行。
	- 锁对象：
		- 由于很多时候wait是通过锁进行调用的，锁甚至可以是object类型的，但是sleep只能调用Thread变量的。
	- 唤醒：
		- wait()使用后释放当前线程的锁，随机访问其他同步代码，其线程进入阻塞状态，后不进行notify()唤醒其线程就永远不会执行了，sleep()超过规定时间后会继续执行。
	- ### 为什么wait,notify,notifyall这些方法不在thread类里面运行？
	  java提供的是对象级的锁不是线程级的锁
	- ### synchronized修饰静态方法和非静态方法有什么区别？为什么？
	  修饰静态方法获取的是类锁（可以同时访问其内部其他非静态方法），修饰非静态方法实际上是对调用该方法的对象加锁（可以同时访问其内部其他非静态方法），可以访问其内部的
	  
	  类的静态成员(变量和方法)在类加载的时候就会分配内存，属于类本身，非静态成员（变量和方法）只有在类的对象产生（创建类的实例）时才会分配内存，属于类的对象。
	- ### synchronized代码块的锁一般用啥？
	  一般用.class文件，因为一个类只对应一个.class文件，或者多个线程传入的相同的修改变量，也是唯一的，以及用final修饰的变量
	- ### ReentrantLock和synchronized的区别？
	  原理：
		- ReentrantLock底层依赖的是AQS，synchronized底层依赖的是monitor监视器。
	- 范围：
		- ReentrantLock锁的范围有局限性，仅适用于代码块范围，而synchronized可以锁住代码块、对象实例、方法，类。
	- 唤醒：
		- ReentrantLock可以配合condition，实现分组唤醒需要的线程；synchronized要么随机唤醒一个，要么唤醒全部线程。
	- 等待中断：
		- ReentrantLock可以让等待的线程中断，一定程度上可以避免死锁，synchronized不能，等待的线程只能一直等下去。
	- 异常：
		- ReentrantLock发生异常时，程序需要自己通过unLock()去释放锁，则很可能造成死锁现象，synchronized修饰的代码在执行异常时，会自动释放线程占有的锁，不需要程序员去控制释放锁，因此基本不会导致死锁现象发生。
	- ### volatile与synchronized区别？
		- 原理：
			- volatile是基于内存屏障实现，不会导致死锁，synthronized是基于锁机制，synthronized的性能弱一点，
			- volatile保证修改的值可以立即被更新到主存中，synchronized在释放锁之前会把对变量的修改刷新到主存里面去
		- 范围：
			- volatile只能用于变量，而synchronized可以用于变量，方法，类
		- 高并发特性：
			- volatile只能保证修改的可见性但是不能保证原子性可能会导致获取的变量对应的内存为空，synchronized两者都可以保证