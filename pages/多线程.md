- ## 线程状态
	- 新建态 ：[[Thread类]]，[[Runnable接口]]，[[Callable接口]]
	- 新建态-->就绪态 ：调用Thread.start()方法
	-
	- [[就绪态]]-->运行态 ：等待到CPU执行权
	-
	- [[运行态]]-->就绪态 ：线程礼让：[[Thread.yield()方法]]
	- 运行态-->阻塞态 ：[[Thread.sleep()方法]]，[[Thread.join()方法]]，[[锁对象.wait()方法]]
	- 运行态-->死亡态 ：Thread.stop()方法，线程自然运行结束
	-
	- [[阻塞态]]—>运行态
- ## 线程同步
	- [[volatile]]
	- [[Synchronized]]
	- [[ReentrantLock]]
	- [[锁对象.wait()方法]]
- ## 守护线程
	- 实现 ：通过Thread.setDemon(false),来将用户线程变成守护线程，
	- 当所有用户线程结束时，守护线程也会自己销毁及时其有任务在运行，除了这一个特点其他和用户线程相同，比如：GC垃圾回收线程
- ## 面试
	- ### 为什么使用多线程？
		- 因为单线程处理能力低。打个比方，一个人去搬砖与几个人去搬砖，一个人只能同时搬一车，但是几个人可以同时一起搬多个车。
	- ### java为什么需要线程同步？
		- 当多个线程访问同一数据并作出修改时，为保证其逻辑的有序性所以需要实现线程同步，多个线程按照一定次序进行访问。
	- ### sleep和wait的区别：
	  使用位置：
		- wait()只能用于同步必须包裹在synchronized下面，sleep什么情况下的线程中都行。
	- 锁对象：
		- 由于很多时候wait是通过锁进行调用的，锁甚至可以是object类型的，但是sleep只能调用Thread变量的。
	- 唤醒：
		- wait()使用后释放当前线程的锁，随机访问其他同步代码，其线程进入阻塞状态，后不进行notify()唤醒其线程就永远不会执行了，sleep超过规定时间后会继续执行。
	- ### ReentrantLock和synchronized的区
	  原理：
		- ReentrantLock底层依赖的是AQS，synchronized底层依赖的是monitor监视器。
	- 范围：
		- ReentrantLock锁的范围有局限性，仅适用于代码块范围，而synchronized可以锁住代码块、对象实例、方法，类。
	- 唤醒：
		- ReentrantLock可以配合condition，实现分组唤醒需要的线程；synchronized要么随机唤醒一个，要么唤醒全部线程。
	- 等待中断：
		- ReentrantLock可以让等待的线程中断，一定程度上可以避免死锁，synchronized不能，等待的线程只能一直等下去。
	- 异常：
		- ReentrantLock发生异常时，程序需要自己通过unLock()去释放锁，则很可能造成死锁现象，synchronized修饰的代码在执行异常时，会自动释放线程占有的锁，不需要程序员去控制释放锁，因此基本不会导致死锁现象发生。
	- ### 为什么wait,notify,notifyall这些方法不在thread类里面运行？
	  java提供的是对象级的锁不是线程级的锁