- ### java创建线程的方法？
  
  继承Thread方法
  
  实现Runnable接口，优势，不受单一继承的局限性，但是需要用主线程对其进行代理，再调用start
  
  实现Callable接口，内部方法为call,有返回值可以确定是完成的是哪一个线程,需要通过excutorservice和future进行管理获取到返回值
- ### java为什么需要线程同步？
  
  当多个线程访问同一数据并作出修改时，为保证其逻辑的有序性所以需要实现线程同步，多个线程按照一定次序进行访问。
- ### java实现同步的方法？
  
  volatile,synchronized,lock,线程的wait方法
- ### synchronized原理
  
  主要为了执行同步操作
  
  会为其修饰的变量，代码块（可以自由定义锁的类型），方法给予一个锁，如果不同synchronized修饰的东西如果是使用的相同的锁的话，只有一个可以拥有这个锁，
  
  当锁内任务完成线程进入死亡状态后会释放锁随机唤醒一个，
  
  对于多线程工作都公用同一个锁时，线程会变成串行的。
- ### ReentrantLock和synchronized的区
  
  原理：ReentrantLock底层依赖的是AQS，synchronized底层依赖的是monitor监视器。
  
  范围：ReentrantLock锁的范围有局限性，仅适用于代码块范围，而synchronized可以锁住代码块、对象实例、方法，类。
  
  唤醒：ReentrantLock可以配合condition，实现分组唤醒需要的线程；synchronized要么随机唤醒一个，要么唤醒全部线程。
  
  等待中断：ReentrantLock可以让等待的线程中断，一定程度上可以避免死锁，synchronized不能，等待的线程只能一直等下去。
  
  异常：ReentrantLock发生异常时，程序需要自己通过unLock()去释放锁，则很可能造成死锁现象，synchronized修饰的代码在执行异常时，会自动释放线程占有的锁，不需要程序员去控制释放锁，因此基本不会导致死锁现象发生。
- ### 为什么wait,notify,notifyall这些方法不在thread类里面运行？
  java提供的是对象级的锁不是线程级的锁
- ### ReentrantLock
  ReentrantLock默认是非公平锁，