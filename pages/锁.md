- ## 锁的四种状态
	- ### 无锁
	  就是所有线程都可以访问
	- ### 偏向锁
	  当初次执行sychronized代码部分的时候会将其锁对象变成偏向锁
	  当没有多个线程争抢资源时，后续访问也会自动获得此锁，从而不存在重复的释放锁和加锁
	- ### 轻量级锁
	  当锁是偏向锁时同时其他线程对其发生争抢，则其锁对象会变成轻量级锁，其他线程会通过自旋的方式获取锁，一般默认自旋次数是十次，由虚拟机参数决定
	- ### 重量级锁
	  如果锁竞争情况严重，某个线程自旋次数达到最大次仍然没有获得资源的话就，锁对象就会由轻量级锁变为重量级锁，这时候线程陷入等待，直到被唤醒。
- ## 锁的优化
	- 1.减少锁持有的时间，不需要锁了就将其及时释放
	- 2.不要不停的对锁进行释放和请求，会消耗大量性能
	- 3.将大对象拆成小对象挨个进行锁，提高并行度，比如分段锁
	- 4.依据任务性质将锁分离，比如读写锁
- ## 公平锁/非公平锁
	- 公平锁：公平锁下多线程会按照申请锁的顺序获取锁，不会争抢，唤醒线程的开销大
		- ```java
		  private ReentrantLock lock = new ReentrantLock(true);  
		  ```
	- 非公平锁：非公平锁会发生争抢，可能导致线程饥饿和优先级反转，但是可以减少唤醒线程的CPU开销
	-
- ## 乐观锁/悲观锁
	- 乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。. 因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。
	- 悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。. 因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据，例如：Synchronized
- ## 重入锁/不可重入锁
- 可重入锁：在同一个线程里面可以重复获取锁对象而不会发生死锁，这种机制使得同一个线程在嵌套调用的过程中能够重复获得锁而不会出现死锁的情况。例如：ReentrantLock
- ```java
  public class Counter {
      private int count = 0;
      private ReentrantLock lock = new ReentrantLock();
  
      public void increment() {
          lock.lock();
          try {
              count++;
              if (count < 10) {
                  increment();
              }
          } finally {
              lock.unlock();
          }
      }
  
      public int getCount() {
          return count;
      }
  }
  
  ```
- 不可重入锁：获取锁后，不能再次获取否则会发生死锁，例如：Synchronized
- ```java
  public class Counter {
      private int count = 0;
  
      public synchronized void increment() {
          count++;
          if (count < 10) {
              increment();
          }
      }
  
      public int getCount() {
          return count;
      }
  }
  
  ```