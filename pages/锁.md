- ## 锁的四种状态
	- ### 无锁
	  就是所有线程都可以访问
	- ### 偏向锁
	  当初次执行sychronized代码部分的时候会将其锁对象变成偏向锁
	  当没有多个线程争抢资源时，后续访问也会自动获得此锁，从而不存在重复的释放锁和加锁
	- ### 轻量级锁
	  当锁是偏向锁时同时其他线程对其发生争抢，则其锁对象会变成轻量级锁，其他线程会通过自旋的方式获取锁，一般默认自旋次数是十次，由虚拟机参数决定
	- ### 重量级锁
	  如果锁竞争情况严重，某个线程自旋次数达到最大次仍然没有获得资源的话就，锁对象就会由轻量级锁变为重量级锁，这时候线程陷入等待，直到被唤醒。
- ## 锁的优化
	- 1.减少锁持有的时间，不需要锁了就将其及时释放
	- 2.不要不停的对锁进行释放和请求，会消耗大量性能
	- 3.将大对象拆成小对象挨个进行锁，提高并行度，比如分段锁
	- 4.依据任务性质将锁分离，比如读写锁
- ## 公平锁/非公平锁
	- 公平锁：公平锁下多线程会按照申请锁的顺序获取锁，不会争抢，唤醒线程的开销大
	- 非公平锁：非公平锁会发生争抢，可能导致线程饥饿和优先级反转，但是可以减少唤醒线程的CPU开销
		- ```java
		  import java.util.concurrent.locks.ReentrantLock;
		  
		  public class FairLockExample {
		      private ReentrantLock lock = new ReentrantLock(false);
		    	//private ReentrantLock lock = new ReentrantLock(true); 
		    	//公平锁打印出来的线程号是连续相同的，非公平锁则是不相同的
		      private int count = 0;
		  
		      public void increment() {
		          lock.lock();
		          try {
		              count++;
		              System.out.println("Thread " + Thread.currentThread().getName() + " incremented count to " + count);
		          } finally {
		              lock.unlock();
		          }
		      }
		  
		      public static void main(String[] args) {
		          FairLockExample example = new FairLockExample();
		  
		          // 创建两个线程并启动
		          Thread t1 = new Thread(() -> {
		              for (int i = 0; i < 5; i++) {
		                  example.increment();
		              }
		          }, "Thread-1");
		  
		          Thread t2 = new Thread(() -> {
		              for (int i = 0; i < 5; i++) {
		                  example.increment();
		              }
		          }, "Thread-2");
		  
		          t1.start();
		          t2.start();
		      }
		  }
		  
		  ```
- ## 乐观锁/悲观锁
	- 乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。 因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。
	- 实现
		- 1.CAS，如果内存位置V的值等于预期的A值，则将该位置更新为新值B，否则不进行任何操作。
		- 许多CAS的操作是自旋的：如果操作不成功，会一直重试，直到操作成功为止。
		- 2.版本号机制，在数据表加上数据版本号version,每线程需要修改数据时，先读取数据获取版本号，在提交更改时如果当前的version和刚刚读取到的version相同就允许进行相应操作，然后将version++
		- 3.AtomicInteger
	- 悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据，例如：Synchronized，ReentrantLock
- ## 重入锁/不可重入锁
- 可重入锁：在同一个线程里面可以重复获取锁对象而不会发生死锁，这种机制使得同一个线程在嵌套调用的过程中能够重复获得锁而不会出现死锁的情况。例如：ReentrantLock
- ```java
  public class Counter {
      private int count = 0;
      private ReentrantLock lock = new ReentrantLock();
  
      public void increment() {
          lock.lock();
          try {
              count++;
              if (count < 10) {
                  increment();
              }
          } finally {
              lock.unlock();
          }
      }
  
      public int getCount() {
          return count;
      }
  }
  
  ```
- 不可重入锁：获取锁后，不能再次获取否则会发生死锁，例如：Synchronized
- ```java
  public class Counter {
      private int count = 0;
  
      public synchronized void increment() {
          count++;
          if (count < 10) {
              increment();
          }
      }
  
      public int getCount() {
          return count;
      }
  }
  
  ```
- ## 读写锁
	- 在多个线程进行读这个行为的时候不互斥，在进行读写，写写操作的时候互斥，提高了读取时的效率，同时保证了读写的安全性
	- 实现：ReadWriteLock接口，实现类ReentrantReadWriteLock
-